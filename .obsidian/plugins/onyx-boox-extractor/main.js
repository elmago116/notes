/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// main.ts
__export(exports, {
  default: () => OnyxBooxExtractorPlugin
});
var import_obsidian = __toModule(require("obsidian"));

// src/models/onyx-boox-extractor-settings.ts
var DEFAULT_SETTINGS = {
  permanentNotePrefix: "perm.",
  literatureNotePrefix: "lit.",
  referenceNotePrefix: "ref.",
  createReferenceNote: true
};

// src/utils/create-literature-note-content.ts
var createLiteratureNoteContent = (noteDetails, referenceNoteId, referenceInfo) => {
  return `---
_Source_: ${referenceInfo.title}
_Section_: ${noteDetails.section}
_Page Number_: ${noteDetails.page}
_Time_: ${noteDetails.creationTime.toISOString()}

---

> ${noteDetails.originalText}

---

_Reference Note_: [[${referenceNoteId}]]

---`;
};

// src/utils/create-permanent-note-content.ts
var createPermanentNoteContent = (noteDetails, literatureFileName, referenceNoteId, referenceInfo) => {
  return !noteDetails.annotation || noteDetails.annotation.replace(/\n/g, "").trim() === "" ? void 0 : `---

tags: 
  - ${referenceInfo.title.replace(/ /g, "_")}

---

${noteDetails.annotation}

---

_Literature Note_: [[${literatureFileName}]]
_Reference Note_: [[${referenceNoteId}]]

---
`;
};

// src/utils/create-reference-note-content.ts
var createReferenceNoteContent = (referenceInfo) => {
  return `

Title: ${referenceInfo.title}
Authors: ${referenceInfo.authors}
`;
};

// src/utils/generate-note-file-name.ts
var NoteType;
(function(NoteType2) {
  NoteType2["Reference"] = "referenceNotePrefix";
  NoteType2["Literature"] = "literatureNotePrefix";
  NoteType2["Permanent"] = "permanentNotePrefix";
})(NoteType || (NoteType = {}));
var generateNoteFileName = (settings, noteType, fileName, uniquePostfix) => {
  if (noteType === NoteType.Permanent)
    return `${settings[noteType]}${uniquePostfix}`;
  const fileNamePart = fileName.trim().replace(/\s/g, "_").toLowerCase();
  return `${settings[noteType]}${fileNamePart}.${uniquePostfix}`;
};

// node_modules/nanoid/index.browser.js
var random = (bytes) => crypto.getRandomValues(new Uint8Array(bytes));
var customRandom = (alphabet, defaultSize, getRandom) => {
  let mask = (2 << Math.log(alphabet.length - 1) / Math.LN2) - 1;
  let step = -~(1.6 * mask * defaultSize / alphabet.length);
  return (size = defaultSize) => {
    let id = "";
    while (true) {
      let bytes = getRandom(step);
      let j = step;
      while (j--) {
        id += alphabet[bytes[j] & mask] || "";
        if (id.length === size)
          return id;
      }
    }
  };
};
var customAlphabet = (alphabet, size = 21) => customRandom(alphabet, size, random);

// src/utils/generate-zettel-id.ts
var generateZettelId = (zettelDate) => {
  const nanoid = customAlphabet("1234567890abcdef", 10);
  if (!zettelDate)
    zettelDate = new Date();
  return `${zettelDate.toISOString().replace(/-|:|\./g, "")}-${nanoid(5)}`;
};

// src/utils/get-strings-between.ts
var getStringBetween = (text, after, before) => {
  const textArray = text.split(after);
  return textArray.length > 0 ? textArray[0].split(before)[0] : "";
};

// src/create-reference-note.ts
var createReferenceNote = (vault, settings, referenceInfo) => __async(void 0, null, function* () {
  const zettelId = generateZettelId();
  const referenceNoteContent = createReferenceNoteContent(referenceInfo);
  const referenceNoteFileName = generateNoteFileName(settings, NoteType.Reference, referenceInfo.title, zettelId);
  yield vault.create(`${referenceNoteFileName}.md`, referenceNoteContent);
  return referenceNoteFileName;
});

// src/create-zettel-notes.ts
var createZettelNotes = (vault, settings, referenceNoteId, referenceInfo, noteDetails) => __async(void 0, null, function* () {
  const zettelId = generateZettelId(noteDetails.creationTime);
  const litId = generateNoteFileName(settings, NoteType.Literature, referenceInfo.title, zettelId);
  const literatureNoteContent = createLiteratureNoteContent(noteDetails, referenceNoteId, referenceInfo);
  yield vault.create(`${litId}.md`, literatureNoteContent);
  const permanentNoteContent = createPermanentNoteContent(noteDetails, litId, referenceNoteId, referenceInfo);
  const permanentNoteFileName = generateNoteFileName(settings, NoteType.Permanent, "", zettelId);
  if (permanentNoteContent)
    yield vault.create(`${permanentNoteFileName}.md`, permanentNoteContent);
});

// src/utils/is-version-2.ts
var isVersion2 = (fileContent) => {
  return !fileContent.contains("\u3010Original Text\u3011");
};

// src/parse-onyx-note.ts
var parseNote = (readingNote) => {
  return readingNote.raw && isVersion2(readingNote.raw) ? parseNoteV2(readingNote) : parseNoteV1(readingNote);
};
var parseNoteV1 = (readingNoteObj) => {
  const readingNote = readingNoteObj == null ? void 0 : readingNoteObj.raw;
  const readingNoteLines = readingNote.split("\n");
  return {
    section: readingNoteLines[1],
    creationTime: new Date(getStringBetween(readingNote, "Time\uFF1A", "\u3010Original Text\u3011").trim()),
    originalText: getStringBetween(readingNote, "\u3010Original Text\u3011", "\u3010Annotations\u3011"),
    annotation: getStringBetween(readingNote, "\u3010Annotations\u3011", "\u3010Page Number\u3011"),
    page: Number(getStringBetween(readingNote, "\u3010Page Number\u3011", "\n").trim())
  };
};
var parseNoteV2 = (readingNoteObj) => {
  const readingNote = readingNoteObj == null ? void 0 : readingNoteObj.raw;
  const readingNoteLines = readingNote.split("\n");
  const firstNoteLine = readingNoteLines[0];
  readingNoteLines.shift();
  return {
    section: readingNoteObj.section,
    creationTime: new Date(firstNoteLine.split("|")[0].trim()),
    originalText: readingNoteLines.join("\n").split("\u3010Note\u3011")[0],
    annotation: readingNote.split("\u3010Note\u3011").length > 0 ? readingNote.split("\u3010Note\u3011")[1] : void 0,
    page: Number(firstNoteLine.split("Page No.:")[1].trim())
  };
};

// src/extract-onyx-notes.ts
var extractOnyxReadingNotesV1 = (vault, settings, fileContent) => __async(void 0, null, function* () {
  const NOTE_SEPARATOR = "-------------------";
  let readingNotesStringArray = fileContent.split(NOTE_SEPARATOR);
  const firstNote = readingNotesStringArray.shift();
  let firstNoteLines = firstNote.split("\n");
  const title = firstNoteLines.shift().split("|")[1].replace(/<<|>>/g, "");
  const authors = firstNoteLines.shift();
  firstNoteLines.reverse().push("\n");
  firstNoteLines = firstNoteLines.reverse();
  readingNotesStringArray.push(firstNote);
  readingNotesStringArray = readingNotesStringArray.filter((note) => note.contains("\u3010Original Text\u3011"));
  const referenceInfo = {
    title,
    authors
  };
  const readingNotesArray = readingNotesStringArray.map((note) => {
    return { raw: note };
  });
  const referenceNoteId = yield createReferenceNote(vault, settings, referenceInfo);
  for (const readingNote of readingNotesArray) {
    const noteDetails = parseNote(readingNote);
    yield createZettelNotes(vault, settings, referenceNoteId, referenceInfo, noteDetails);
  }
});
var extractOnyxReadingNotesV2 = (vault, settings, fileContent) => __async(void 0, null, function* () {
  var _a;
  const NOTE_SEPARATOR = "-------------------";
  const mainMetadata = fileContent.split("\n")[0];
  let readingNotesArray = fileContent.split("\n");
  readingNotesArray.shift();
  readingNotesArray = readingNotesArray.join("\n").split(NOTE_SEPARATOR);
  const titleAndAuthor = mainMetadata.split("|")[1];
  const title = titleAndAuthor.split(">>")[0].replace(/<|>/g, "");
  const authors = (_a = titleAndAuthor.split(">>")) == null ? void 0 : _a[1];
  const referenceInfo = {
    title,
    authors
  };
  const readingNotesArrayObj = parseChapters(readingNotesArray);
  const referenceNoteId = yield createReferenceNote(vault, settings, referenceInfo);
  for (const readingNote of readingNotesArrayObj) {
    const noteDetails = parseNote(readingNote);
    yield createZettelNotes(vault, settings, referenceNoteId, referenceInfo, noteDetails);
  }
});
var parseChapters = (readingNotesArray) => {
  let currentChapter;
  const readingNotes = [];
  for (const note of readingNotesArray) {
    const noteLines = note.split("\n").filter((line) => line !== "");
    const fullFirstLine = noteLines[0];
    const creationTimeCandidate = fullFirstLine == null ? void 0 : fullFirstLine.split("|")[0].trim();
    const creationTimeCandidateDate = new Date(creationTimeCandidate);
    if (creationTimeCandidateDate.toString() === "Invalid Date") {
      currentChapter = fullFirstLine;
      noteLines.splice(0, 1);
    }
    readingNotes.push({
      section: currentChapter,
      raw: noteLines.join("\n")
    });
  }
  return readingNotes;
};
var extractOnyxReadingNotes = (vault, settings, fileContent) => __async(void 0, null, function* () {
  if (isVersion2)
    yield extractOnyxReadingNotesV2(vault, settings, fileContent);
  else
    yield extractOnyxReadingNotesV1(vault, settings, fileContent);
});

// main.ts
var OnyxBooxExtractorPlugin = class extends import_obsidian.Plugin {
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      this.registerEvent(this.app.workspace.on("file-menu", (menu, file) => {
        menu.addItem((item) => {
          item.setTitle("Extract Onyx file").setIcon("document").onClick(() => __async(this, null, function* () {
            yield extractOnyxReadingNotesByFile(this.settings, file);
          }));
        });
      }));
      this.addSettingTab(new OnyxBooxExtractorSettingTab(this.app, this));
    });
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
};
var OnyxBooxExtractorSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Settings" });
    new import_obsidian.Setting(containerEl).setName("Permanent note id prefix").setDesc("").addText((text) => text.setPlaceholder("perm.").setValue(this.plugin.settings.permanentNotePrefix).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.permanentNotePrefix = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("Literature note id prefix").setDesc("").addText((text) => text.setPlaceholder("lit.").setValue(this.plugin.settings.literatureNotePrefix).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.literatureNotePrefix = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("Create Reference Notes?").setDesc("").addToggle((text) => text.setValue(this.plugin.settings.createReferenceNote).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.createReferenceNote = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("References note id prefix").setDesc("").addText((text) => text.setPlaceholder("ref.").setValue(this.plugin.settings.referenceNotePrefix).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.referenceNotePrefix = value;
      yield this.plugin.saveSettings();
    })));
  }
};
function extractOnyxReadingNotesByFile(settings, file) {
  return __async(this, null, function* () {
    const fileContent = yield this.app.vault.cachedRead(file);
    yield extractOnyxReadingNotes(this.app.vault, settings, fileContent);
  });
}

/* nosourcemap */